{
  "hash": "e0614b2a8cdd2a669863269430c9a810",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro to ggplot, dplyr, and pivoting\"\nauthor: \"Isaac Vock\"\ndate: \"2025-01-23\"\ncategories: [stats]\nformat: \n  html:\n    toc: true\neditor: visual\n---\n\n\nMuch of this class will center on manipulating and visualizing data. This \nsection gets into that.\n\nTo run much of the code in this walkthrough, you will need to load the tidyverse libraries (technically we will primarily use `ggplot`, `dplyr`, and `tidyr`, with a tiny bit of `tibble`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tidyverse packages\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\nThroughout, I will use the `mtcars` dataset, which is a built-in R data frame (meaning it's always available to you within any R installation; run `print(mtcars)` on your console to see what I mean) that contains automobile data extracted from the 1974 *Motor Trend* magazine. The dataset has 32 rows (each representing a different car model, with the name of that model being the row names of the data frame), and 11 columns (variables). These variables include:\n\n- **mpg** (miles per gallon): numeric data on the fuel efficiency\n- **cyl** (Number of cylinders): typically 4, 6, or 8\n- **hp** (horsepower): numeric data on the engine power\n- **wt** (Weight in 1000s of lbs): numeric data on the car's weight\n- **disp** (Displacement in cubic inches): engine size\n\nWhy this data? Because it's an R education classic.\n\n## An introduction to ggplot\n\nThe `ggplot2` package is part of the tidyverse collection. It implements the **Grammar of Graphics**, which allows you to build plots layer by layer. The general structure is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = <DATA>,\n       mapping = aes(x = <X-VARIABLE>,\n                     y = <Y-VARIABLE>)) +\n  <GEOM_FUNCTION>()\n```\n:::\n\n\nwhere things in `<...>` are general placeholders that you would have to edit to get working code. The general features are:\n\n  - `ggplot(data = ...)`: specifies the dataset.\n  - `aes()`: Which columns map to the x-axis, y-axis, color, size, etc. of the plot\n  - `geom_*()`: The geometry or type of plot (points, bars, lines, tiles, lines, tiles, etc.)\n\n\n### Making scatter plots with `geom_point()`\n\nScatter plots are used to visualize the relationship between two numeric variables.\n\nExample Plot `mpg` (miles per gallon) against `wt` (weight of the car) from the `mtcars` dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = wt, y = mpg)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n- We are mapping `wt` on the x-axis and `mpg` on the y-axis\n- `geom_point()` draws the scatter plot by making each data points x and y a point (circular by default).\n\nYou can add more aesthetics, for example coloring the points by the number of cylinders:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = wt, y = mpg, color = factor(cyl))) +\n  geom_point() + \n  labs(color = \"Cylinders\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nNote that `cyl` is numeric in `mtcars`, so we can convert it to a factor (`factor(cyl)`) when using it as a categorical variable (a variable with a finite set of values). \n\n\n### Jittered scatter plots with `geom_jitter()`\n\nA jitter plot helps when data points overlap (i.e., have identical x or y values). It adds a small random noise to the position of each point, preventing them from lying exactly on top of each other\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = mtcars, aes(x = factor(cyl),\n                     y = mpg)\n) +\n  geom_jitter(\n    width = 0.2,\n    height = 0,\n    alpha = 0.7\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n- Here, x is `factor(cyl)`, turning cylinders into discrete categories.\n- We add jitter on the x-axis (using `width = 0.2`), and none on the y-axis (`height = 0`).\n- `alpha = 0.7` makes the points slightly transparent to give you a sense of point density.\n\n\n### Histograms with `geom_histogram()`\n\nA histogram is used to visualize the distribution of a single numeric variable. Let's look at the distribution of miles per gallon (`mpg`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = mpg)) +\n  geom_histogram(binwidth = 2,\n                 fill = \"skyblue\",\n                 color = \"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n- `binwidth = 2` sets the width of the histogram bins.\n- `fill` sets the color of the bars, `color` sets the outline color.\n\nSomtimes, data can have a large range of frequencies, making it helpful to display the counts on a log scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = mpg)) +\n  geom_histogram(color = 'black') +\n  scale_y_log10()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in scale_y_log10(): log-10 transformation introduced infinite values.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 12 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n### Heatmaps with `geom_tile()`\n\nA heatmap is useful for visualizing a matrix of values or the relationship between two categorical variables, colored by a numeric value. One common example is a correlation matrix among numeric variables.\n\nA somewhat silly example of this is below; all you need to know is that `data` ends up being a data frame with columns `X`, `Y`, and `Z`, where `X` and `Y` are categorical variables (i.e., they take on a finite set of values) and `Z` is a continuous numeric variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dummy data\nx <- LETTERS[1:20]\ny <- paste0(\"var\", seq(1,20))\ndata <- expand.grid(X=x, Y=y)\ndata$Z <- runif(400, 0, 5)\n \n# Heatmap \nggplot(data, aes(X, Y, fill= Z)) + \n  geom_tile()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n- `geom_tile()` draws the heatmap squares, one for each X and Y combo. `fill = Z` colors the tiles by the Z-value.\n\n\nFor a more hardcore example, let's create a correlation matrix among select columns in `mtcars` (e.g., `mpg`, `wt`, `hp`, `disp`) and plot it as a heatmap:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute correlations\ncor_mat <- cor(mtcars[, c(\"mpg\", \"wt\", \"hp\", \"disp\")])\n\n# Convert to a long format dataframe for plotting\ncor_df <- as.data.frame(as.table(cor_mat))\ncolnames(cor_df) <- c(\"Var1\", \"Var2\", \"Correlation\")\n\n# Plot with geom_tile()\nggplot(data = cor_df, aes(x = Var1, y = Var2, fill = Correlation)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"blue\", mid = \"white\", high = \"red\", midpoint = 0) +\n  theme_minimal() +\n  coord_fixed() +\n  labs(title = \"Correlation Heatmap\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n- `cor()` calculates the correlation matrix, this has rows and columns \"mpg\", \"wt\", \"hp\", and \"disp\", with entries being the correlation between of these variables and all of the other varialbes.\n- `as.table()` and then `as.data.frame()` converts the matrix into a long format with columns for what was the rowname of the correlation matrix (renamed to \"Var1\") and what was the colname of the correlation matrix (renamed to \"Var2\"), as well as the correlation value between \"Var1\" and \"Var2\".\n- `scale_fill_gradient2()` helps us visualize positive vs. negative correlations using a diverging color scale.\n- `coord_fixed()` ensures each tile is square\n\n\n### ggplot themes\n\nSo far, we have discussed the basics of how to plot data with ggplot. One thing that might stand out about this plot is various aspects of its aesthetics:\n\n- The gray checkerboard background\n- The font sizes\n- Text on axes and color legends\n- etc.\n\nTo change these aspects, we can use the concept of \"themes\" in ggplot2. This is done through the `theme()` function.\n\nStarting with the simple scatter plot we made earlier, we can update it's look with a number of [built-in themes](https://ggplot2.tidyverse.org/reference/ggtheme.html) that ggplot provides. For example, I am a fan of the \"classic\" theme:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = wt, y = mpg)) + \n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nOther popular themes include:\n\n- theme_minimal()\n- theme_dark()\n- theme_void()\n\nYou can also customize every aspect of your plot with the use of `theme()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = wt, y = mpg)) + \n  geom_point() +\n  theme(\n      # Plot background\n  plot.background = element_rect(fill = \"ivory\", color = NA),\n  \n  # Panel (plot area) settings\n  panel.background = element_rect(fill = \"ghostwhite\"),\n  panel.grid.major = element_line(color = \"gray90\", linetype = \"dashed\"),\n  panel.grid.minor = element_line(color = \"gray95\", linetype = \"dotted\"),\n  \n  # Axis customization\n  axis.title = element_text(face = \"bold\", color = \"darkblue\", size = 12),\n  axis.text = element_text(color = \"navy\", size = 10),\n  axis.line = element_line(color = \"navy\", linewidth = 0.5),\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nCheck out the documentation (e.g., by running `?ggplot2::theme` or going to\nthis link) to learn more. There is also a nice article on the topic of customizing\nthemes [here](https://rpubs.com/mclaire19/ggplot2-custom-themes).\n\n\n## An introduction to dplyr and tidyr\n\ndplyr and tidyr are both part of the tidyverse collection of packages:\n\n  - dplyr: Focuses on data manipulation and transformation. It provides a set of \"verbs\" that correspond to common data manipulation tasks (e.g., filter, select, mutate, summarise, arrange). These functions are often used together in a pipeline (with the `%>%` operator) to create clean, readable code that closely expresses the steps of your data processing.\n  - tidyr: Specializes in reshaping data between wide and long (the latter called \"tidy\") formats. In a tidy dataset, each variable is its own column, each observation is its own row, and each value is in its own cell. By using functions like `pivot_longer()` and `pivot_wider()`, tidyr helps you reorganize your data so that it's consistent with these tidy data principles, facilitating analysis and visualization later on.\n\n### Combining commands with `%>%`\n\nThroughout this tutorial, I will use the so-called \"magrittr pipe\" (`%>%`). This allows you to pass the result of one function as the first argument of the next function. It can make your code a lot cleaner and easier to read. A simple example of the pipe is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyvect <- c(1, 2, 3)\n\n# Sum the elements of the vector\nsum(myvect)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Same thing, but with a pipe\nmyvect %>% sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nThese are two ways of doing the same thing. Either you can provide `myvect` to the function `sum()` as normal, or you can pipe it in; these are equivalent. The real power of `%>%` comes from how it allows you to stitch together multiple operations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  subset(mpg > 20) %>%\n  ggplot(aes(x = wt, y = mpg)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n- First, we pipe our data into `subset()`, which is a base R function that takes a data frame as input and returns only the rows that match a certain condition (`mpg > 20` in this case).\n- We are then piping the output of `subset()` into `ggplot()`, which is the equivalent of writing `ggplot(data = subset(mtcars, mpg > 20), aes(x = wt, y = mpg)) + ...`\n\nTechnically, newer versions of R (version 4.1 and later) have a base R version of the pipe, known as the native pipe (`|>`). They work pretty similarly, but I am an old hat and thus like to stick with the trusty magrittr pipe. You should feel free to use either though.\n\n### Selecting columns with `dplyr::select()`\n\n`select()` can be used to choose (or exclude) specific columns in a data frame. The simplest usage of `select()` is to specify the columns you want to keep by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  dplyr::select(mpg, cyl, hp) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl  hp\nMazda RX4         21.0   6 110\nMazda RX4 Wag     21.0   6 110\nDatsun 710        22.8   4  93\nHornet 4 Drive    21.4   6 110\nHornet Sportabout 18.7   8 175\nValiant           18.1   6 105\n```\n\n\n:::\n:::\n\n\nThis returns a data frame with just those three columns. You can also exclude columns by using a `-` sign:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  dplyr::select(-hp) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n:::\n\n\nThis returns all columns except `hp`.\n\nIf you want to get fancy, sometimes you don't know the column names beforehand -- maybe they come from user input to a function. In those cases, you can store column names in a charater variable and use `!!` (the \"bang-bang\" operator) to unquote them (convert them from strings to as if you were typing them in yourself without the `\" \"`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols_to_select <- c(\"mpg\", \"wt\")\n\nmtcars %>%\n  select(!!cols_to_select) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg    wt\nMazda RX4         21.0 2.620\nMazda RX4 Wag     21.0 2.875\nDatsun 710        22.8 2.320\nHornet 4 Drive    21.4 3.215\nHornet Sportabout 18.7 3.440\nValiant           18.1 3.460\n```\n\n\n:::\n:::\n\n\n### Adding columns to a data frame with `dplyr::mutate()`\n\n`mutate()` allows you to add new columns (variables) or modify existing columns.\n\nFor instance, suppose you want to create a new column named `mpg_level`, categorizing `mpg` into \"high\" or \"low\" mileage based on whether a car gets more than 20 mpg:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_new <- mtcars %>%\n  mutate(mpg_level = ifelse(mpg > 20, \"high\", \"low\"))\n```\n:::\n\n  \n- We take the `mtcars` data frame and pipe (`%>%`) it to `mutate()`. This means we are passing `mtcars` as the first argument of `mutate`, which needs to be a data frame.\n- `ifelse()` assigns a value of \"high\" to rows for which `mpg > 20`, and \"low\" otherwise.\n- The resulting new column is called `mpg_level`, and it is only present in the new data frame `mtcars_new`\n\n\n### Grouping and summarizing with `dplyr::summarise()` and `dplyr::group_by()`\n\nWhen working with data grouped by categories, you can compute summary statistics per group. \n\nExample: find the average miles per gallon (`mpg`) for each number of cylinders:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  group_by(cyl) %>% \n  summarise(mean_mpg = mean(mpg), n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n    cyl mean_mpg     n\n  <dbl>    <dbl> <int>\n1     4     26.7    11\n2     6     19.7     7\n3     8     15.1    14\n```\n\n\n:::\n:::\n\n\n- `group_by(cyl)` splits the data by the cyl variable. Whatever happens next will be done on each group separately.\n- `summarise()` calculates summary statistics. Here, we calculate the average value (`mean()`) of the `mpg` column, and the number of data points (count of rows, `n()`).\n\n\n### Filtering data frames with `dplyr::filter()`\n\nUse `filter()` to only keep rows that pass a certain set of conditions. For example, to select cars with more than 20 mpg:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  filter(mpg > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\nYou can also combine filtering with grouping and only keep entire groups that pass a certain filter, for example by using `any()` and `all()`. For example, to keep only the groups of cars with the same cylinder that have at least one member of the group with more than 150 horsepower:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  group_by(cyl) %>%\n  filter(any(hp > 150))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 21 × 11\n# Groups:   cyl [2]\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 4  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 5  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 6  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 7  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n 8  17.8     6  168.   123  3.92  3.44  18.9     1     0     4     4\n 9  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3\n10  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3\n# ℹ 11 more rows\n```\n\n\n:::\n:::\n\n\n- `any(hp > 150)` is evaluated within each `cyl` group.\n- If any car in that group has `hp > 150`, all rows of that group are kept.\n\nBy contrast, if you wanted to keep only the groups where all cars exceeded 150 horsepower:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  group_by(cyl) %>%\n  filter(all(hp > 150))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 11\n# Groups:   cyl [0]\n# ℹ 11 variables: mpg <dbl>, cyl <dbl>, disp <dbl>, hp <dbl>, drat <dbl>,\n#   wt <dbl>, qsec <dbl>, vs <dbl>, am <dbl>, gear <dbl>, carb <dbl>\n```\n\n\n:::\n:::\n\n\n- `all(hp > 150)` means every car in the group must have `hp` greater than 150.\n\n\n### Pivoting data longer and wider with `tidyr`\n\nThe `tidyr` package provides convenient functions to reshape data:\n\n- `pivot_longer()`: Makes wide data longer, gathering columns into key-value pairs.\n- `pivot_wider()`: Spreads long (tidy) data into wider format, creating new columns.\n\nLet's create a simplifed data frame with a few columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_data <- mtcars %>%\n  dplyr::select(mpg, cyl, hp, wt) %>%\n  rownames_to_column(var = \"car_name\")\n\nhead(car_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name  mpg cyl  hp    wt\n1         Mazda RX4 21.0   6 110 2.620\n2     Mazda RX4 Wag 21.0   6 110 2.875\n3        Datsun 710 22.8   4  93 2.320\n4    Hornet 4 Drive 21.4   6 110 3.215\n5 Hornet Sportabout 18.7   8 175 3.440\n6           Valiant 18.1   6 105 3.460\n```\n\n\n:::\n:::\n\n\n- `row_names_to_column` converts the row names of the data frame into a column. This is generally good practice. It is part of the `tibble` package, included in the `tidyverse`.\n- `head()` prints the first 6 rows of a data frame to give you an easy to parse look at its contents\n\nSuppose we want to pivot this data so that `mpg`, `hp`, and `wt` become rows under a single \"measurement\" column, with their values in another column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_data_long <- car_data %>%\n  pivot_longer(\n    cols = c(mpg, hp, wt),\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n\nhead(car_data_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  car_name        cyl measurement  value\n  <chr>         <dbl> <chr>        <dbl>\n1 Mazda RX4         6 mpg          21   \n2 Mazda RX4         6 hp          110   \n3 Mazda RX4         6 wt            2.62\n4 Mazda RX4 Wag     6 mpg          21   \n5 Mazda RX4 Wag     6 hp          110   \n6 Mazda RX4 Wag     6 wt            2.88\n```\n\n\n:::\n:::\n\n\n- `cols` denotes the set of columns you want to \"pivot\"\n- `names_to` is the name of the new columns that will store the names of the columns in `cols`. We are \"pivoting longer\", so these three columns in `cols` will no longer exist, with their content spread throughout the data frame. This new column (\"measurement\") will track which rows correspond to information originally contained in these columns\n- `values_to` is the name of the new column that will store the values of the original columns.\n\nWe can go back to the wide format by \"pivoting wider\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_data_wide <- car_data_long %>%\n  pivot_wider(\n    names_from = measurement,\n    values_from = value\n  )\n\nhead(car_data_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  car_name            cyl   mpg    hp    wt\n  <chr>             <dbl> <dbl> <dbl> <dbl>\n1 Mazda RX4             6  21     110  2.62\n2 Mazda RX4 Wag         6  21     110  2.88\n3 Datsun 710            4  22.8    93  2.32\n4 Hornet 4 Drive        6  21.4   110  3.22\n5 Hornet Sportabout     8  18.7   175  3.44\n6 Valiant               6  18.1   105  3.46\n```\n\n\n:::\n:::\n\n\n- `names_from` specifies a column from which new column names will be derived.\n- `values_from` will specify which column to get values that will be put int the new columns.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}