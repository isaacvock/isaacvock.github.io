{
  "hash": "895b693177c9f41391ba65ffa5e0ab6f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro to R: Day 1\"\nauthor: \"Isaac Vock\"\ndate: \"2025-1-21\"\ncategories: [stats]\nformat: \n  html:\n    toc: true\nengine: knitr\neditor: \n  markdown: \n    wrap: 72\n---\n\n\nThis worksheet will walk you through some basic concepts in R. I would suggest copying code shown here into an R script and running it yourself so that you can play around with the presented examples.\n\n\n## Pre-requisite knowledge for `simple_calc()`\n\n### Math in R\n\nThe simplest use case of R is using it to do math:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 1 # Addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n10 - 1.5 # Subtraction\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.5\n```\n\n\n:::\n\n```{.r .cell-code}\n2 * 3 # Multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n10.12 / 17.99 # Division\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5625347\n```\n\n\n:::\n\n```{.r .cell-code}\n5 ^ 2 # Exponentiation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n### Numeric variables in R\n\nYou can store numbers in \"variables\". This is like a special box in your computer's memory labeled with a name (like `my_number`). When you put a number into this box (for example, `10`), we say you have assigned the value 10 to the variable `my_number`.\n\nIn R, you'd do this by writing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_number <- 10\nmy_number\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Seeing the value of variables\n\nTyping and executing `print(my_number)` or just `my_number` will print out the value of the variable to your console.\n:::\n\nHere is what's happening in this code:\n\n1.  `my_number` is the label on the box in memory.\n2.  `<-` is like an arrow pointing from the value to the box, meaning \"put this value in that box\".\n3.  \\`10 is the actual number you are storing.\n\nYou can then do math like this just like with regular numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_number * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_number ^ 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_number - 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n`my_number` does not change value in any of the above lines. To change the value of `my_number`, you would have to assign it the new value with `<-` again:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_number # my_number is 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_number <- 1001 # my_number is now 1001\nmy_number # Confirm new value of my_number\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1001\n```\n\n\n:::\n:::\n\n\n### Strings in R\n\nYou can store more than numbers in variables. For example, you can store text, which is referred to as a \"string\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_string <- \"Hello\"\nmy_string2 <- 'Bye'\n\nmy_string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_string2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Bye\"\n```\n\n\n:::\n:::\n\n\nYou tell R that you are storing text by wrapping that text in `\"\"` or `''`.\n\n\n::: {.callout-tip collapse=\"true\"}\n## Useful string tools (aka functions)\n\nBelow are some useful tools that R provide you to work with strings. These are called functions, a concept discussed later. \n\n1. `paste(..., sep = \" \")`: `paste()` allows you to stitch together multiple strings, with a chosen separator text between strings (`sep` argument). Having no separator (`sep = \"\"`) is identical to using a different function `paste0()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring1 <- \"Hello\"\nstring2 <- \"friend.\"\nstring3 <- \"It's been too long\"\n\npaste(string1, string2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello friend.\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(string1, string2, sep = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hellofriend.\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste0(string1, string2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hellofriend.\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(string1, string2, string3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello friend. It's been too long\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(string1, string2, collapse = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello friend.\"\n```\n\n\n:::\n:::\n\n\n2. `nchar()`: This will give you the number of individual characters in your text string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring1 <- \"Hello\"\nnchar(string1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n3. `gsub(pattern, replacement, x)`: This allows you to look for the string `pattern` in the query string `x`, and replace it with the string `replacement`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext <- \"Hello, Hello, Hello!\"\ngsub(\"Hello\", \"Hi\", text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi, Hi, Hi!\"\n```\n\n\n:::\n:::\n\n\n4. `grepl(pattern, x)`: This is similar to `gsub()` but just searches for string `pattern` in string `x` and spits out `TRUE` if it finds it\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext <- \"Hello, Hello, Hello!\"\ngrepl(\"Hello\", text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThere is a whole R package called [stringr](https://stringr.tidyverse.org/) devoted to making working with strings in R easier and more intuitive, so you might want to look into that as well!\n:::\n\n\n\n### Booleans in R\n\nAnother thing that is commonly stored in variables is logical values (TRUE or FALSE), otherwise known as \"booleans\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_bool <- TRUE\nmy_bool2 <- FALSE\n\nmy_bool\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_bool2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nYou can do a sort of math with booleans, referred to as \"boolean logic\". This takes as input two (in the case of AND and OR) or one (in the case of NOT) boolean variables and outputs a new boolean. The most common examples are:\n\n**AND (`&`)**\n\n-   Both of the booleans must be TRUE for the output to be TRUE:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & TRUE # This is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & FALSE # This is FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & TRUE # This is FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & FALSE # This is FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n**OR (`|`)**\n\n-   At least one of the booleans must be TRUE for the output of this to be TRUE\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE | TRUE # This is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | FALSE # This is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE | TRUE # This is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE | FALSE # This is FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n**NOT (`!`)**\n\n-   Unlike AND and OR, this takes a single boolean value as input\n-   This reverses the value of the boolean:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!TRUE # This is FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!FALSE # This is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nFinally, you can compare the value of two variables to see if they are the same. If the are `variable_1 == variable_2` will return `TRUE`, otherwise it will return `FALSE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"Hello\" == \"Hello\" # TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"Hi\" == \"Bye\" # FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 == 1 # TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_number <- 1\nmy_number2 <- 2\nmy_number == my_number2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n### Functions in R\n\nA function in R is like a \"recipe\" for a mini \"machine\" that does one specific job. You give it some inputs (called *arguments*), it follows the steps you've defined, and then it gives you a result.\n\nFunctions help you organize your code so you can reuse it instead of writing the same steps again and again. Here is a simple example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function name: my_function\n# Arguments: x and y\n# Output: x + y\nmy_function <- function(x, y){\n  \n  # 1. Inside the curly braces, write the steps of what you will do with x and y\n  \n  # We will add x and y\n  result <- x + y\n  \n  # 2. Tell the function what to output (i.e., its \"return value\")\n  return(result)\n  \n}\n```\n:::\n\n\n-   `my_function` is the name of the function (like a label on the mini machine).\n-   `function(x,y) { ... }` says \"I am creating a function that expects two inputs, called `x` and `y`.\n-   Inside the `{ ... }`, you can write as much code as you want; this is the instructions for what you want the function to do with the inputs\n-   `return(result)` sends the output of the function back to you.\n\nAfter creating `my_function`, you can *call* it (computer science lingo meaning \"use the function\") by typing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_function(3,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_new_number <- my_function(2, 2)\nmy_new_number\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\nSometimes, you want one (or more) of your function's inputs to have a \"fallback\" value if the user doesn't supply one. That's where **default arguments** come in. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_new_function <- function(x, y = 10){\n\n  result <- x + y\n  \n  return(result)\n  \n}\n```\n:::\n\n\n`my_new_function` now only needs you to supply x. You can supply `x` and `y`, but if you don't supply `y`, it will give `y` a default value of 10 by default:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_new_function(x = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_new_function(x = 2, y = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_new_function(2, 20) # Will fill arguments in order, so x = 2 and y = 20 here\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Advanced function advice\n\n### Tip 1: argument with small set of possible values\n\nSometimes, one of the arguments of your function may have a set number of possible values that you intend for a user to input. You can specify this as such:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_options <- function(a, b, greeting = c(\"Hi\", \"Bye\", \"Huh?\")){\n  \n  # Check to make sure the user supplied one of the valid options\n  greeting <- match.arg(greeting)\n  \n  print(greeting)\n  \n  result <- a + b\n  \n  return(result)\n  \n}\n\n# Uses first option by default\nmy_options(2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_options(2, 2, \"Huh?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Huh?\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n### Tip 2: Catching errors\n\nIn all of our examples so far, we have assumed that the user has supplied a particular kind of data for each argument. Mostly, we have assumed that numbers are being passed to many of our example functions, numbers that we can add. What if they messed up though and passed a string, for example? We can catch this and throw an error message:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_valuecheck <- function(a, b){\n  \n  # check if a is a number\n  stopifnot(is.numeric(a))\n  \n  # check if b is a number, but with a slightly different strategy\n  # if-statements are discussed more later.\n  if(!is.numeric(b)){\n    \n    stop(\"b isn't a number\")\n    \n  }\n  \n  result <- a + b\n  \n  return(result)\n}\n```\n:::\n\n\nThis function will work as normal if `a` and `b` are numbers, but will throw informative error messages if not. You will also get an error in the old version of this function that didn't have the `stopifnot()` lines, but this error might be far more cryptic and hard to understand. You will also get a different error depending on what is wrong about `a` and/or `b`, further confusing you or other users of this function.\n:::\n\n### Control flow (if-else statements)\n\nAn if-else statement is one of the most common ways to control the flow of a program. It lets your code make decisions based on whether a condition is `TRUE` or `FALSE`.\n\n-   `if` checks if something is `TRUE`\n-   `else` covers what happens if it is not `TRUE`\n-   You can add extra steps in between using `else if` to handle different possible conditions\n\nThe basic structure looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition1){\n  # This code runs if 'condition1' is TRUE\n}else if(condition2){\n  # This code runs if 'condition2' is TRUE\n}else{\n  # This code runs if both 'condition1' and 'condition2' are FALSE\n}\n```\n:::\n\n\nThink of this code as asking a set of questions:\n\n-   If condition1 is `TRUE`, do something.\n-   Else if condition2 is `TRUE`, do something else\n-   Else, if neither condition1 nor condition2 are `TRUE`, do a default thing.\n\nA real example might look like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\n\nif(x > 3){\n  print(\"x is greater than 3\")\n}else if(x < 5){\n  print(\"x is between 3 and 5\")\n}else{\n  print(\"x is greater than or equal to 5\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x is greater than 3\"\n```\n\n\n:::\n:::\n\n\nConditions in R must evaluate to a single `TRUE` or `FALSE`. Common ways to form conditions are comparison operators:\n\n-   `==`: Check if two things are equal (e.g., `a == b`). `a` and `b` can be numbers, strings, booleans, etc.\n-   `!=`: Check if two things are not equal 1 `<`, `>`, `<=`, `>=`: Less than, greater than, less than or equal to, or greater than or equal to, respectively.\n\nHere is an example of how you might use control flow in a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreetUser <- function(user_input){\n  \n  # Check if user_input equals \"Hello\"\n  if (user_input == \"Hello\"){\n    return(\"Hi there! Nice to meet you.\")\n  }else if(user_input == \"Goodbye\"){\n    return(\"See you later! Take care.\")\n  }else{\n    return(\"I'm not sure how to respond to that...\")\n  }\n  \n}\n\ngreetUser(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi there! Nice to meet you.\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngreetUser(\"Comment allez-vous?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I'm not sure how to respond to that...\"\n```\n\n\n:::\n:::\n\n\n## Pre-requisite knowledge for `vector_calc()`\n\n### Vectors\n\nIn R, a vector is a container that holds multiple values of the **same data type** (such as numbers, strings, or booleans). You can think of it like a row of boxes, each containing a value of the same kind.\n\nYou can create a vector with the `c()` function (short for \"combine\" or \"concatenate\"). Here are a few example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A numeric vector\nnumbers <- c(10, 20, 30, 40)\n\n# A character (string) vector\nwords <- c(\"cat\", \"dog\", \"bird\")\n\n# A boolean vector\nbools <- c(TRUE, FALSE, TRUE)\n```\n:::\n\n\nOften, you will want to access specific elements or sets of elements of a vector. To do this, you can use square brackets `[ ]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the first element of 'numbers'\nnumbers[1] # 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get the second element of 'words'\nwords[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dog\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get multiple elements at once\nnumbers[c(1, 3)] # This gives the 1st and 3rd elements: c(10, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 30\n```\n\n\n:::\n\n```{.r .cell-code}\n# Exclude specific elements\nbools[-1] # This gives everything but the 1st element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n:::\n\n\nYou can also change values of specific elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# See what 'numbers' is now\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n\n```{.r .cell-code}\n# Change a value\nnumbers[2] <- 99\n\n# Check 'numbers' now\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 99 30 40\n```\n\n\n:::\n:::\n\n\nSometimes, it will be useful to check what kind of data is in a vector. This can be done with the `class()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(numbers) # \"numeric\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(words) # \"character\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(bools) # \"logical\" (another word for boolean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\nYou can also check the value with functions like `is.numeric()`. `is.character()`, or `is.logical()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(numbers) # TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(words) # FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(numbers) # FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.logical(numbers) # FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(words) # TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.logical(bools) # TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Useful vector functions\n\nBelow are some useful functions that allow you to create vectors or lookup some information about a vector:\n\n1.  `length(v)`: returns the number of elements in the vector v:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(c(1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n2.  `seq(from, to, length.out)` or `seq(from, to, by)`: Creates a vector starting from the number `from` (default value of 1), to the number `to` (default value of 1). If you set `length.out`, then you will get a vector of `length.out` elements. If you set `by`, then you specify the distance between adjacent elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 5, length.out = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(from = 1, to = 5, by = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n3.  `rep(x, times)`: Creates a vector containing the value `x` repeated `times` times:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = 1, times = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 1 1 1 1 1 1 1 1\n```\n\n\n:::\n:::\n\n\n4.  `start:end`: Same as `seq(from = start, to = end, by = 1)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n0.5:2.5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5 1.5 2.5\n```\n\n\n:::\n:::\n\n:::\n\n### Loops\n\nA loop is a way to tell R to \"do something multiple times\". This unlocks one of the powerful aspects of computers: their ability to do multiple things quickly.\n\nThere are two commonly used types of loops: **for** loops and **while** loops.\n\nA **for** loop in R iterates (or \"loops\") over each element of a vector and does something with it. For example, if we want to print every element of a numeric vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(10, 20, 30, 40)\n\n# Loop over the values\nfor(value in numbers){\n  print(value)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n[1] 20\n[1] 30\n[1] 40\n```\n\n\n:::\n\n```{.r .cell-code}\n# Loop over the vector 1 to the length of the vector\nfor(i in 1:length(numbers)){\n  \n  print(numbers[i])\n \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n[1] 20\n[1] 30\n[1] 40\n```\n\n\n:::\n\n```{.r .cell-code}\n# Fancier alternative to the above code\nfor(i in seq_along(numbers)){\n  \n  print(numbers[i])\n  \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n[1] 20\n[1] 30\n[1] 40\n```\n\n\n:::\n:::\n\n\nWhat's happening here?\n\n1.  `for (value in numbers)` means \"go through each element of `numbers` and temporarily call that element `value`. `for(i in 1:length(numbers)` creates a vector (`1:length(numbers)`) which is a vector of whole numbers from 1 to the length of the vector numbers. Each of these whole numbers is then temporarily called `i`. `seq_along(numbers)` does pretty much the same things as `1:length(numbers)`.\n2.  `print(value)` means we display the current `value` on the screen.\n3.  R will do this until it has gone through all elements in `numbers`.\n\nA **while** loop keeps going as long as some condition is `TRUE`. Suppose we want to keep adding numbers from a vector until the total sum exceeds 50:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(10, 20, 30, 40, 50)\ntotal <- 0 # Start total at 0\ni <- 1 # Start index at 1\n\nwhile(i <= length(numbers) & total <= 50){\n  \n  # Add to total\n  total <- total + numbers[i]\n  \n  # Track which element we are on\n  i <- i + 1\n  \n}\n\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 60\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\nWhat's going on here?\n\n1.  `while(i <= length(numbers) && total <= 50)` - The loop will continue running **while** two conditions are both `TRUE`:\n\n-   We haven't reached the end of the vector (`i <= length(numbers)`) and\n-   The `total` hasn't exceeded 50 (`total <= 50`).\n\n1.  Inside the loop, we add the `i`-th element of `numbers` to `total`.\n2.  We then move `i` to the next element by adding 1.\n3.  As soon as one of the conditions in 1. become `FALSE`, the loop stops.\n\n## Pre-requisite knowledge for `calc_df_stats()`\n\n### Navigating directories and file paths\n\nWhen you work in R, you'll often deal with files (like CSV files) that sit in folders (directories) on your computer. To load these files into R so that you can work with and analyze them, you need to tell R where they are. In addition, it is important to know where you are while working in R.\n\nWhen I say \"know where you are\", I am referring to your \"working directory\". When you open up Rstudio, there is some folder on your computer that R will call your \"working directory\". You can see what this folder is at any time with `getwd()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You get to see what my working directory path is\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C:/Users/isaac/Documents/Simon_Lab/isaacvock.github.io/posts/Rintro_day1\"\n```\n\n\n:::\n:::\n\n\nIf you want to change this directory, you can switch to a new directory with `setwd(\"/path/to/new/working/directory\")`.\n\nYou can specify a file path to `setwd()` in one of two ways:\n\n1.  As an **absolute path**. This means specifying *exactly* where a folder is on your computer (like \"C:/Users/YourName/Documents/\" on Windows or \"/Users/YourName/Documents/ on Macs).\n2.  As a **relative path**. This means telling R how to get from the current working directory to the folder. For example, if you are in the directory \"Documents\" and want to move to a folder called \"data\" inside of \"Documents, you could run `setwd(\"data\")`, assuming \"Documents\" is your current working directory.\n\n### Reading a file with readr\n\nThe [readr](https://readr.tidyverse.org/) package (part of the tidyverse collection of packages), provides user-friendly functions for reading in data. For example, you can read a csv file like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- read_csv(\"path/to/mydata.csv\")\n```\n:::\n\n\n-   `read_csv(\"path/to/mydata.csv\")` reads the CSV file located at the specified path (either a relative or absolute path) and creates a data frame (more on those soon).\n-   We're storing that data frame in a variable called `my_data`.\n\n### Data Frames\n\nA data frame is a table-like structure with rows and columns, commonly used for storign datasets in R. Each **column** is usually a vector of a particular type (numeric, character, boolean, etc.), and all columns have the **same length**.\n\nTo create a data frame you can run code like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages <- c(30, 25, 35)\n\n# You can either specify the vector directly\n# or provide the name of a vector you previously created\npeople_df <- data.frame(\n  Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n  Age = ages,\n  Score = c(100, 95, 90)\n)\n\npeople_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Name Age Score\n1   Alice  30   100\n2     Bob  25    95\n3 Charlie  35    90\n```\n\n\n:::\n:::\n\n\nHere are some ways you can interact with the data inside of a data frame:\n\n1.  You can grab an entire column with `$` or `[[<col name as string>]]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This will give you a vector\npeople_df$Name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"   \"Bob\"     \"Charlie\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# This will be the same vector\npeople_df[[\"Name\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"   \"Bob\"     \"Charlie\"\n```\n\n\n:::\n:::\n\n\n2.  You can grab an entire column with `[ , <column number>]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This will give you a data frame with one column\npeople_df[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"   \"Bob\"     \"Charlie\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# This will give you a data frame with multiple columns\npeople_df[,c(1, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Name Age\n1   Alice  30\n2     Bob  25\n3 Charlie  35\n```\n\n\n:::\n:::\n\n\n3.  You can get all columns in a specific row with `[<row number>, ]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This will give you a data frame with one row\npeople_df[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Name Age Score\n1 Alice  30   100\n```\n\n\n:::\n\n```{.r .cell-code}\n# This will give you a data frame with multiple rows\npeople_df[c(1, 3), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Name Age Score\n1   Alice  30   100\n3 Charlie  35    90\n```\n\n\n:::\n:::\n\n\n### Lists\n\nA list is like a container in R that can hold a mix of different types of items, like a data frame. Lists are more flexible though, and can hold things of different sizes. A list can hold:\n\n-   A numeric vector\n-   A string vector\n-   A single number\n-   An entire data frame\n-   Another list\n\nAll at once!\n\nHere is how you can create a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\n  name = \"Alice\",\n  age = 30,\n  scores = c(100, 95, 90),\n  is_student = FALSE,\n  df = data.frame(a = c(1, 2, 3), b = c(\"a\", \"b\", \"c\"))\n)\n```\n:::\n\n\nTo access elements of a list, you can:\n\n1.  Use the `$` operator (if the elements have names):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list$scores\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100  95  90\n```\n\n\n:::\n:::\n\n\n2.  The `[[ ]]` operator with the element's name (if it has one), or its position:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[[\"name\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Fancy looping over lists (and data frames)\n\nOften, you will want to go element by element of a list and do something with each element. In addition, data frame columns are equivalent to elements of a list (actually, under the hood, a data frame is just a list that forces the list elements to be the same size). You could write a for loop, but there are popular alternatives that can make your code cleaner and easier to read. R has a version of these, but the R package `purrr` has improved versions of these that I prefer.\n\n1. `map()`: takes a single list as input\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\nnumbers <- list(\n  c(1, 2, 3),\n  c(4, 5, 6),\n  c(10, 20, 30, 40, 50)\n)\n\n# Outputs a list, one element for original element of the list\nmap(numbers, function(x) sum(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 6\n\n[[2]]\n[1] 15\n\n[[3]]\n[1] 150\n```\n\n\n:::\n\n```{.r .cell-code}\n# Outputs a vector numbers, one element per original list element\n# Also using an alternative notation\nmap_dbl(numbers, ~ sum(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   6  15 150\n```\n\n\n:::\n:::\n\n\n\n2. `map2()`: takes two lists as input\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- list(\n  c(1, 2, 3),\n  c(4, 5, 6),\n  c(10, 20, 30, 40, 50)\n)\n\nnumbers2 <- list(\n  c(-1, -2, -3),\n  c(12, 13),\n  c(2, 4, 6, 8, 10, 12)\n)\n\n# Outputs a list, one element for original element of the list\nmap2(numbers, numbers2, ~ sum(.x) + sum(.y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0\n\n[[2]]\n[1] 40\n\n[[3]]\n[1] 192\n```\n\n\n:::\n\n```{.r .cell-code}\n# Outputs a vector numbers, one element per original list element\nmap2_dbl(numbers, numbers2, function(x, y) sum(x) + sum(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   0  40 192\n```\n\n\n:::\n:::\n\n\n3. `pmap()` allows you to provide a named list of inputs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A list of vectors\nlists_of_inputs <- list(\n  a = c(1, 3, 5),\n  b = c(2, 4, 6),\n  c = c(10, 20, 30)\n)\n\npmap(lists_of_inputs, function(a, b, c) a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 13\n\n[[2]]\n[1] 27\n\n[[3]]\n[1] 41\n```\n\n\n:::\n\n```{.r .cell-code}\npmap_dbl(lists_of_inputs, function(a, b, c) a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 27 41\n```\n\n\n:::\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}